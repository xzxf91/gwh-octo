<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style type="text/css">
        body, ul, li {
            margin: 0;
            padding: 0;
            list-style: none;
            font-size: 14px;
            font-family: "\5FAE\8F6F\96C5\9ED1", Helvetica;
        }

        #ul1 {
            margin: 10px auto;
            padding: 15px;
            width: 70%;
            border: 1px solid #11c900;
        }

        #ul1 li {
            height: 35px;
            line-height: 35px;
            /*截取文字并且显示...*/
            text-overflow: ellipsis; /*截取超出的部分用省略号代替*/
            white-space: nowrap; /*强制不换行*/
            overflow: hidden; /*溢出隐藏*/
        }

        .c0 {
            background: #FFCCFF;
        }

        .c1 {
            background: #ffe470;
        }

        .hover {
            background: #11c900;
        }
    </style>
</head>
<body>
<ul id="ul1">
    <li>在没有努力之前,请先不要谈天赋！</li>
    <li>定义自己的本阶段学习目标,直接上薪资;勿忘初心,方得始终;</li>
    <li>站在台风口上,猪都能飞起来;互联网没有大家想象的那样进入寒冬!</li>
    <!--以上是给大家的箴言,下面是我们课程学习的说明-->
    <li id="li4">周一到周五每天必须要保持3-4小时学习的时间:看视频预习、做作业或者自己总结笔记在或者自己拿实战项目练习</li>
    <li>正式课我们会有六次考试:第二周、第三周、第四周、第五周、第八周、第九周,考试的时候周末班(在线周末)周六早上9:30到学校,补考统一在周日晚上下课;时间错过了本次考试作废,考试费不发;</li>
    <div>加错地方了</div>
</ul>

<script type="text/javascript">
    var oUl = document.getElementById("ul1");
    var oLis = oUl.getElementsByTagName("li");
    for (var i = 0; i < oLis.length; i++) {
        oLis[i].className = "c" + i % 2;
        oLis[i].oldClass = "c" + i % 2;
        oLis[i].onmouseover = function () {
            this.className = "hover";
        };
        oLis[i].onmouseout = function () {
            this.className = this.oldClass;
        };
    }
    // 1)获取oUl下所有的元素子节点(获取所有子节点用childNodes)
    /*
     * children:获取所有子节点下所有元素节点
     * @ parameter:
     *   curEle:[object]获取目前操作的元素对象
     * @ return:[Array]获取元素的元素集合
     * by team on 2015/10/26
     */
    /*function children(curEle) {
     var allNodes = curEle.childNodes, ary = [];//先获取所有的子节点，ary是用来存储元素节点的
     for (var i = 0; i < allNodes.length; i++) {
     if (allNodes[i].nodeType === 1) {//循环再从所有子节点找出元素节点
     ary.push(allNodes[i]);//找到元素节点，然后存储到ary数组里面
     }
     }
     return ary;//返回我们的ary元素子节点
     }*/
    /*function children(curEle) {
     var allNodes = curEle.childNodes, ary = [];
     for (var i = 0; i < allNodes.length; i++) {
     var cur = allNodes[i];
     cur.nodeType === 1 ? ary[ary.length] = cur : null;
     }
     return ary;
     }
     var oulChild = children(oUl);
     console.log(oulChild);*/

    //2)获取某一个元素的上一个哥哥元素节点(上一个哥哥节点previousSibling)

    /*function prev(curEle) {
     if (curEle.previousElementSibling) {
     return curEle.previousElementSibling;//直接获取上一个哥哥元素节点
     }//如果浏览器兼容previousElementSibling就执行，不兼容就执行下面
     var pre = curEle.previousSibling;
     while (pre && pre.nodeType != 1) {//如果有哥哥节点，并且不是元素节点的话就继续查找，直到找到哥哥元素节点查找结束
     pre = pre.previousSibling;//当前pre就是我们要找的哥哥元素节点
     }
     return pre;
     }*/
    /*var oLi4 = document.getElementById("li4");
     var pre = prev(oLi4);
     console.log(pre);*/

    //3)获取所有的哥哥元素节点
    /*function prevAll(curEle) {
     var pre = curEle.previousSibling, ary = [];//获取哥哥节点，空数组用来存储找到的哥哥元素节点
     while(pre){
     pre.nodeType === 1 ? ary.unshift(pre) : null;
     pre=pre.previousSibling;
     }
     return ary;
     }*/
    /*function prevAll(curEle) {
     var ary = [];//用来存储
     var preEle = prev(curEle);
     while (preEle) {
     ary.unshift(preEle);
     preEle = prev(preEle);
     }
     return ary;
     }
     var oLi4 = document.getElementById("li4");
     console.log(prevAll(oLi4));*/

    //4) 获取下一个弟弟元素节点next
    /*function next(curEle) {
     if(curEle.nextElementSibling){
     return curEle.nextElementSibling;
     }
     var nex = curEle.nextSibling;
     while (nex && nex.nodeType !== 1) {
     nex = nex.nextSibling;
     }
     return nex;
     }*/
    /*var oLi4 = document.getElementById("li4");
     console.log(next(oLi4));*/

    // 5)获取所有的弟弟元素节点nextAll
    /*
     * nextAll 获取所有的弟弟元素节点
     * @ parameter
     *   curEle:[object] 获取目前操作的元素对象
     * @ return:[Array]  获取元素的元素集合
     * by team on 2015/10/27
     */
    /*function nextAll(curEle){
     var nex=curEle.nextSibling,ary=[];
     while(nex){
     if(nex.nodeType===1){
     ary.push(nex);
     }
     nex=nex.nextSibling;
     }
     return ary;
     }*/
    /*function nextAll(curEle){
     var ary=[];
     var nex=next(curEle);
     while(nex){
     nex.nodeType===1? ary[ary.length]=nex:null;
     nex=next(nex);
     }
     return ary;
     }
     var oLi4 = document.getElementById("li4");
     console.log(nextAll(oLi4));*/

    //6) 获取相邻的(上一个哥哥元素节点+下一个弟弟元素节点)元素节点 sibling
    function sibling(curEle){
        var pre=curEle.previousSibling, nex=curEle.nextSibling,ary=[];
        while (nex && nex.nodeType !== 1) {
            nex = nex.nextSibling;
        }
        while (pre && pre.nodeType != 1) {
            pre = pre.previousSibling;
        }
        ary.push(pre,nex);
        return ary;
    }
    var oLi4 = document.getElementById("li4");
    console.log(sibling(oLi4));

    //7)获取所有的兄弟元素节点 siblings
    function siblings(curEle) {
        var sib = curEle.parentNode.children, ary = [];
        for (var i = 0; i < sib.length; i++) {
            if (sib[i] !== curEle) {
                ary.push(sib[i]);
            }
        }
        return ary;
    }

    /*var oLi4 = document.getElementById("li4");
     console.log(siblings(oLi4));*/

    //8)获取第一个子元素节点 first
    function first(curEle){
        var fir=curEle.firstChild;
        while(fir.nodeType!==1){
            fir=fir.nextSibling;
        }
        return fir;
    }
    var oUl = document.getElementById("ul1");
    console.log(first(oUl));

    //8)获取最后一个子元素节点 last
    function last(curEle){
        var las=curEle.lastChild,fir=las.previousSibling;
        if(las.nodeType===1){
            return las;
        }
        while(fir && fir.nodeType!==1){
            fir=fir.previousSibling;
        }
        return fir;
    }
    var oUl = document.getElementById("ul1");
    console.log(last(oUl));

    // 9)获取当前元素的索引位置 index
    function index(cur,index){
        for(var i=0; i<cur.length; i++){
            if(cur[i]===index){
                return i;
            }
        }
    }
    var oUl = document.getElementById("ul1");
    var oLis = oUl.getElementsByTagName("li");
    var oLi =document.getElementById("li4");
    console.log(index(oLis,oLi));



    //思考题：
    // 获取下一个弟弟元素节点next
    // 获取所有的弟弟元素节点nextAll
    // 获取相邻的(上一个哥哥元素节点+下一个弟弟元素节点)元素节点 sibling
    // 获取所有的兄弟元素节点 siblings
    // 获取第一个子元素节点 first
    // 获取最后一个子元素节点 last
    // 获取当前元素的索引位置 index
</script>
</body>
</html>